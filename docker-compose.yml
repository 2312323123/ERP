# you have to create .env file next to this file with credentials for it to work
# also put microservices databases credentials here as well as in init-db/create_databases.sql
services:
  nginx:
    build:
      context: ./API-gateway
    networks:
      - outside
      - backend
      - frontend
      - db_admin_sql
      - db_admin_mongo
    ports:
      - "5555:80" # Exposes port 80 on the host and forwards it to port 80 in the container.

  db-psql:
    image: postgres:latest
    networks:
      - backend
      - db_admin_sql
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    # UNCOMMENT THIS TO PERSIST DATA
    # volumes:
    # - ./db_postgres/db_data:/var/lib/postgresql/data
    configs:
      - source: db-psql-create_databases.sql
        target: /docker-entrypoint-initdb.d/create_databases.sql

  pgadmin:
    build:
      context: .
      dockerfile: ./pgadmin/dockerfile_for_pgadmin
    networks:
      - db_admin_sql
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL_PART_BEFORE_AT}@${PGADMIN_DEFAULT_EMAIL_PART_AFTER_AT}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
      # PGADMIN_LISTEN_PORT: 5050
    expose:
      # - "5050"
      - "80"
    # process to find this was pain
    entrypoint: >
      /bin/sh -c "
      mkdir -p /var/lib/pgadmin/storage/${PGADMIN_DEFAULT_EMAIL_PART_BEFORE_AT}_${PGADMIN_DEFAULT_EMAIL_PART_AFTER_AT}/;
      cp /tmp/mountpoint.pgpass /var/lib/pgadmin/storage/${PGADMIN_DEFAULT_EMAIL_PART_BEFORE_AT}_${PGADMIN_DEFAULT_EMAIL_PART_AFTER_AT}/.pgpass;
      chown pgadmin:root /var/lib/pgadmin/storage/${PGADMIN_DEFAULT_EMAIL_PART_BEFORE_AT}_${PGADMIN_DEFAULT_EMAIL_PART_AFTER_AT}/.pgpass;
      chmod 600 /var/lib/pgadmin/storage/${PGADMIN_DEFAULT_EMAIL_PART_BEFORE_AT}_${PGADMIN_DEFAULT_EMAIL_PART_AFTER_AT}/.pgpass;
      /entrypoint.sh
      "
    configs:
      - source: pgadmin-servers.json
        target: /pgadmin4/servers.json
      - source: pgadmin-pgpass
        target: /tmp/mountpoint.pgpass

  react-app:
    build:
      context: ./ERP-frontend # Specify the build context (directory where the Dockerfile is located)
      dockerfile: Dockerfile # Specify the Dockerfile name (if it's named differently)
    # ports:
    #   - "8080:8080"
    volumes:
      - ./ERP-frontend:/app
      - /app/node_modules
    networks:
      - frontend
    stdin_open: true
    tty: true
    expose:
      - "8080"

  # auth_and_permissions:
  #   build:
  #     context: ./auth_and_permissions
  #     dockerfile: Dockerfile
  #   ports:
  #     - "3000:3000" # Expose the NestJS application port
  #   volumes:
  #     - ./auth_and_permissions:/app
  #     - /app/node_modules
  #   networks:
  #     - backend
  #   environment:
  #     - NODE_ENV=development
  #     # command: npm run start:dev
  #     - DB_NAME=${AUTH_SERVICE_DB_NAME}
  #     - DB_USERNAME=${AUTH_SERVICE_DB_USER}
  #     - DB_PASSWORD=${AUTH_SERVICE_DB_PASSWORD}
  #   stdin_open: true
  #   tty: true

  erp-backend:
    build:
      context: ./ERP-backend # Point to the directory containing your Dockerfile
      dockerfile: Dockerfile # Specify Dockerfile if it's named differently
    # ports:
    #   - "3000:3000" # Expose the NestJS application port
    volumes:
      - ./ERP-backend:/app # Mount the current directory to /app in the container for hot reloading
      - /app/node_modules # Avoid mounting node_modules from the host machine
    networks:
      - backend
    environment:
      - NODE_ENV=development # Set the environment to development
    command: npm run start:dev # Start the NestJS app with hot reloading
    stdin_open: true # Keep stdin open
    tty: true # Allocate a pseudo-TTY

#   # db: backend, db_admin_sql
#   # p4admin: db_admin
#   # mongo: backend, db_admin_mongo

networks:
  frontend: # if named frontend_network, for some reason does not work
  outside:
  backend:
  db_admin_sql:
  db_admin_mongo:

configs:
  db-psql-create_databases.sql:
    content: |
      /*
        login to superuser: docker exec -it erp-db-psql-1 psql -U <user_name_from_docker_compose_env_file>
        login to user: docker exec -it erp-db-psql-1 psql -U <user_name> -d <db_name>

        using '-' in env variables here is discouraged as it requires escaping
        WARNING: if you change env variables later on, you can lose all data in the database (can't login)
      */

      -- first microservice
      CREATE DATABASE "${AUTH_SERVICE_DB_NAME}";
      CREATE USER "${AUTH_SERVICE_DB_USER}" WITH PASSWORD '${AUTH_SERVICE_DB_PASSWORD}';
      GRANT ALL PRIVILEGES ON DATABASE "${AUTH_SERVICE_DB_NAME}" TO "${AUTH_SERVICE_DB_USER}";
  pgadmin-pgpass:
    content: db-psql:5432:*:${POSTGRES_USER}:${POSTGRES_PASSWORD}
  pgadmin-servers.json:
    content: |
      {
        "Servers": {
          "1": {
            "Name": "PostgreSQL",
            "Group": "Servers",
            "Host": "db-psql",
            "Port": 5432,
            "MaintenanceDB": "postgres",
            "Username": "${POSTGRES_USER}",
            "ConnectionParameters": {
              "sslmode": "prefer",
              "connect_timeout": "10",
              "passfile": "/.pgpass"
            }
          }
        }
      }
